% kolmogorov_slow: Generation of a Kolmogorov phase screen.
%
% Synopsis:
%
%     p = kolmogorov_slow(dim, r0=dim, orig=0);
%
% yields an array of random phases which follow Kolmogorov law on a square
% pupil of `dim` samples per side with a Fried's parameter equal to `r0`
% (in units of the sampling step, default is to set `r0 = dim`).  If a
% point spread function is to be calculated from the generated phase
% screen, it should be sampled with `r0` greater or equal 2 or 3 samples.
% The returned values are in radians.
%
% If `orig` is specified with a non-zero value, the phases are generated by
% the method of R.G. Lane, A. Glindemann and J.C. Dainty ("Simulation of a
% Kolmogorov phase screen" in Waves in Random Media, vol. 2, pp. 209-224,
% 1992).  Otherwise, a modified algorithm by Thiébaut & Tallon ("Fast
% minimum variance wavefront reconstruction for extremely large
% telescopes", J. Opt. Soc. Am. A, vol. 27, pp. 1046-1059, 2010) is used
% instead.
%
% Author: Éric Thiébaut (2018).
%
function a = kolmogorov_slow(dim, r0, orig)
    % Default arguments.
    if nargin < 2
        r0 = dim;
    end
    if nargin < 3
        orig = 0;
    end

    % Compute the size of the minimum array which holds the phase screen over
    % the pupil.
    n = 2^int32(ceil(log2(dim - 1))) + 1;
    delta = sqrt(6.88*(dim/r0)^(5/3));

    beta = 1.7817974; % 2^(5/6)
    c1 = 3.3030483e-1*delta;
    c2 = 6.2521894e-1*delta;
    c3 = 5.3008502e-1*delta;
    c4 = 3.9711507e-1*delta;
    if orig
        c5 = 4.5420202e-1*delta;
    else
        c5 = 4.4355177e-1*delta;
        l5 = 4.5081546e-1;
        m5 = 9.8369088e-2;
    end
    a = randn(n, n);
    b1 = c2*randn();
    b2 = c2*randn();

    % First set the 4 corners.
    a(1,1) = c1*a(1,1) + b1;
    a(n,1) = c1*a(n,1) + b2;
    a(1,n) = c1*a(1,n) - b2;
    a(n,n) = c1*a(n,n) - b1;

    % Then set all other points from the largest scales to the smallest ones.
    h = n - 1;
    while h > 1
        s = h;   % step size
        h = h/2; % half the step size
        c3 = c3/beta;
        c4 = c4/beta;
        c5 = c5/beta;

        % Mid-point indices.
        j = 1+h:s:n-h; % mid-point indices
        jp = j - h;    % previous indices
        jn = j + h;    % next indices

        % Set the samples at the center of squares.
        for k = 1+h:s:n-h     % mid-point coordinates
            kp = k - h;       % previous position
            kn = k + h;       % next position
            for j = 1+h:s:n-h % mid-point coordinates
                jp = j - h;   % previous position
                jn = j + h;   % next position
                a(j,k) = c3*a(j,k) + 0.25*(a(jp,kp) + a(jp,kn) + ...
                                           a(jn,kp) + a(jn,kn));
            end
        end

        if 2*s < n
            % Set the samples at the center of losanges.
            for k = 1+s:s:n-s     % vertice coordinates
                kp = k - h;       % previous position
                kn = k + h;       % next position
                for j = 1+h:s:n-h % mid-point coordinates
                    jp = j - h;   % previous position
                    jn = j + h;   % next position
                    a(j,k) = c4*a(j,k) + 0.25*(a(j,kp) + a(j,kn) + ...
                                               a(jp,k) + a(jn,k));
                    a(k,j) = c4*a(k,j) + 0.25*(a(k,jp) + a(k,jn) + ...
                                               a(kp,j) + a(kn,j));
                end
            end
        end

        % Set the samples at the borders.
        if orig ~= 0
            % Apply original method.
            for j = 1+h:s:n-h % mid-point coordinates
                jp = j - h;   % previous position
                jn = j + h;   % next position
                a(1,j) = c5*a(1,j) + 0.5*(a(1,jp) + a(1,jn));
                a(n,j) = c5*a(n,j) + 0.5*(a(n,jp) + a(n,jn));
                a(j,1) = c5*a(j,1) + 0.5*(a(jp,1) + a(jn,1));
                a(j,n) = c5*a(j,n) + 0.5*(a(jp,n) + a(jn,n));
            end
        else
            % Apply modified method.
            for j = 1+h:s:n-h % mid-point coordinates
                jp = j - h;   % previous position
                jn = j + h;   % next position
                a(1,j) = c5*a(1,j) + l5*(a(1,jp) + a(1,jn)) + m5*a(1+h,j);
                a(n,j) = c5*a(n,j) + l5*(a(n,jp) + a(n,jn)) + m5*a(n-h,j);
                a(j,1) = c5*a(j,1) + l5*(a(jp,1) + a(jn,1)) + m5*a(j,1+h);
                a(j,n) = c5*a(j,n) + l5*(a(jp,n) + a(jn,n)) + m5*a(j,n-h);
            end
        end
    end

    if dim < n
        t = (n - dim)/2;
        rng = 1+t:dim+t;
        a = a(rng, rng);
    end
end
